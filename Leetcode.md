# LeetCode刷题心得

## 1. 单调栈

### 链接

[单调栈]: https://xyzl.blog.luogu.org/Mono-Stack

### 解决什么问题

​	求下一个最大值。

### AC题目：letecode 907

**暴力思路**：枚举所有子序列，对于每个子序列找到最小值，累加就是答案。时间复杂度O（n^3）。

根据子串**连续性**的特点，抓住这个特征，控制住子串的一端，枚举起来就很方便且有规律。例如，数组[1,2,3,4,5,6,7]，可以这样枚举：

1						2						3						4					5				6			7

1,2					 2,3					 3,4					 4,5				 5,6			 6,7

1,2,3				  2,3,4				  3,4,5				  4,5,6			  5,6,7

1,2,3,4			   2,3,4,5			   3,4,5,6			   4,5,6,7

1,2,3,4,5			2,3,4,5,6			3,4,5,6,7

1,2,3,4,5,6		 2,3,4,5,6,7

1,2,3,4,5,6,7      

这样有规律地枚举子数组可以将暴力解法的时间复杂度降到O（n^2）。

**单调栈思路**：对于每一个元素，计算他左边下一个更小值的位置，和他右边下一个最小值的位置，这样就能找到所有以这个元素为最小值的子数组。因此，两次单调栈，加一次遍历，就可以算出最终答案。

**单调栈+dp**：重新考虑暴力解法，实际上已经有了dp的雏形。如果从斜方向枚举，即1---2----1,2---3---2,3----1，2,3....。可以看到，每轮增加的子数组是所有包含当前最右端的子数组。那么这些子数组的最小值计算能否用到之前轮次遍历的结果呢？

首先，这里要打破一个思维定势，即dp算法不仅可以是相邻两项的关系，也可以跨多项，比如dp[i]  = f(dp[i-k])。所以，以数组[3,5,2,7,4,1,6]为例，考虑6为最右点的子数组时，

6							6

1,6					 	1

4,1,6					  1

7,4,1,6				   1

2,7,4,1,6				1

5,2,7,4,1,6			 1

3,5,2,7,4,1,6		  1

发现，当6遇到下一个更小值前，子数组的最小值一直是6，遇到之后（这里是1），接下来再找最小值其实就与1和6之间的数无关了。而且可以转换为最右点是1的子数组的子问题。这里就可以应用dp。dp[i] = min（b）的和，b为所有以第i个元素为最右的子数组。dp[i] = dp[i-k] + arr[i] * k, k是i到i的下一个最小值的距离。

最终的答案为dp[0] + ... +dp[n-1]。

## 2. DFS

## 3. 滑动窗口

### 框架

1. 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。
3. 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

### 特点

1. 滑动窗口是一个连续的结构，所以适合解决子串的问题。
2. 窗口缩减的过程（left++）是剪枝的过程。当前窗口扩大（right++）一定不会得到最优解时，则窗口缩减（left++）。

### 链接

[滑动窗口]: https://www.cnblogs.com/huansky/p/13488234.html

### AC题目

leetcode3. 无重复字符的最长子串

leetcode438. 找到字符串中所有字母异位词

### 解决什么问题

1. 满足xx条件的区间最值问题

## 4. 双向链表+hashTable（LRU问题，leetcode146）

### 关于链表

​	建立虚头结点（双向还要虚尾结点），这样能在省掉增删结点时不必要的麻烦。

### 关于hashTable

​	哈希映射的关键在于根据**不同**的key值，映射到你想快速取值的空间。

### 关于析构函数

​	析构函数是用来释放对象占用的资源的。如果您在堆空间分配了成员变量，那么您需要在析构函数中释放这些成员变量占用的空间。例如，如果您在构造函数中使用`new`运算符分配了一个指针类型的成员变量，那么您需要在析构函数中使用`delete`运算符释放这个指针占用的空间。

## 5. 二维差分算法

### 思想

​	对区域范围内**所有点**的问题等价于区域**边界点**的问题，缩减了问题考察范围，只需考查边界点，而不必关注问题的所有点。通常伴随着区域的离散化操作（取边界点代表整个区域）。

### AC题目

​	LCP 74. 最强力场问题：找强度最强的区域——》找强度最强的点。

## 6. 在矩阵中的二分法（思路扩展）

### 例题：leetcode 74

### 算法：

1. 常规算法：正常的二分查找。复杂度：
   $$
   log2(m * n), m、n为矩阵的size
   $$

2. 利用升序排列的二维矩阵特点，每次与右上角的元素比较大小，这样稳定删除一行or一列数据。复杂度：
   $$
   log2(m + n)
   $$

## 7. LCA问题

### 例题：leetcode236

### 算法：

我的题解：两次深搜得到root到两个点的路径，比较两个路径即可。（两次深搜+一次遍历）

**官方题解（最优）**：一次深搜，（后序遍历的思路）就是遍历完左右孩子，根据返回结果处理中结点（天然的回溯过程）。（一次深搜）

学数据结构时的题解：一次深搜得到中序序列，遍历这个序列，其中两目标节点之间深度最小的结点即为所求。（一次深搜+一次遍历）

## 8. 期望线性时间找一组数据的统计量

### 例题：leetcode215

### 算法：

是快排的改进，在算法导论9.2章节，不知道为什么期望时间是线性（需要概率论知识），感觉**可以用来装B**。

## 9. hash的两种实现

### unordered_set: 

​	底层是哈希表，能在O（1）时间内插入和查找，但内部无序。

### map：

​	底层是红黑树，能再O（nlogn）时间插入和查找，内部有序。

## 10. 树型dp

### 思路：很好理解，就是自底向上的遍历。一棵树的解由他的子树的解构成，由此写出状态转移方程。

### 例题：leetcode337 打家劫舍iii   leetcode543 二叉树的直径

## 11. 二分法——根本是有序

### 核心：二分也是一个剪枝的过程，每次二分能删掉一半的数据规模。

### 二分法有效的条件：而删掉一半数据后是原问题的子问题（我称之为有子结构性质）。这才能保证问题递归求解。

### 例题：leetcode33. 搜索旋转排序数组

其实这个问题核心在于，基于二分的思路，判断每次应该选择左侧区域还是右侧区域，其中的判断标准不再是简单的nums[mid] == target，而需要分情况仔细讨论。因为剪枝后的数组仍满足旋转数组的特征，所以该问题有子结构性质，所以二分法是可行的。

## 12. 堆

### 自顶向下建堆：

按照完全二叉树的规则，不断插入新元素，调整为堆。时间复杂度O（n*logn）。

### 自底向上建堆：

从第一个非叶节点开始，自下而上，自右而左地调整为堆。时间复杂度O（n）。已有两个堆，给一个堆顶，调整成一个新堆。

### 堆排序：

取堆顶--》最后一个元素放在堆顶--》调整成堆（将父亲左孩子右孩子三者最大的放在堆顶）

## 13. 前缀和

利用**前缀和**可以有效的枚举**子数组和**。S[n]表示数组的前n项和，任意两个S[i] - S[j]就是一个子数组所有项的和。

### 例题：letecode 523.连续的子数组和
